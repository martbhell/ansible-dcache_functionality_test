---

 - name: test a storage element
   hosts: localhost
   gather_facts: True
   force_handlers: True
   become: False

   handlers:
     - name: cleanup
       command: arcrm srm://{{ server }}{{path}}/{{ file }}
     - name: cleanup2
       file: path=/tmp/{{ file }} state=absent
     - name: cleanup3
       file: path=/tmp/{{ file }}{{ item }} state=absent
       with_items:
        - 2
        - 3
        - 4
        - 5

   tasks:
     - block:

       - name: findproxy validity - fails if no (valid) proxy found 
         command: arcproxy -i validityLeft
         register: reg_arcproxy
         changed_when: False
         failed_when:
           - reg_arcproxy.rc != 0 or reg_arcproxy.stdout|int == 0

       - name: arcls SRM dir
         command: "arcls srm://{{ server }}{{ path }}"
         register: reg_arcls
         when: server is defined and path is defined

       - name: arcls SRM path / file
         command: "arcls srm://{{ server }}{{ path }}/{{ file }}"
         register: reg_arclsfile
         failed_when: False
         when: server is defined and path is defined and file is defined

       - name: arcrm SRM file first if it exists
         command: "arcrm srm://{{ server }}{{ path }}/{{ file }}"
         when: 
          - reg_arclsfile.rc|int == 0
          - (server is defined and path is defined and file is defined)

       - name: xrdfs ls
         command: "xrdfs root://{{ server }}{{ path }}"
         register: reg_xrdfs
         when: server is defined and path is defined

       - name: stat bash
         stat: path=/bin/bash
         register: reg_bash

       - name: store bash checksum in a fact
         set_fact: 
           bash_checksum: "{{ reg_bash.stat.checksum }}"

       - name: arccp SRM here to there
         command: "arccp /bin/bash srm://{{ server }}{{ path }}/{{ file }}"
         notify: cleanup
         when: server is defined and path is defined and file is defined

       - name: arccp SRM there to here
         command: "arccp srm://{{ server }}{{ path }}/{{ file }} /tmp/{{ file }}"
         notify: cleanup2
         when: server is defined and path is defined and file is defined


       - name: xrdcp there to here
         command: "xrdcp root://{{ server }}{{ path }}/{{ file }} /tmp/{{ file }}2"
         notify: cleanup3
         when: server is defined and path is defined and file is defined

       - name: stat fetched bash file
         stat: path=/tmp/{{ file }}
         register: reg_bash_1
         when: server is defined and path is defined and file is defined

       - name: stat fetched bash file2
         stat: path=/tmp/{{ file }}2
         register: reg_bash_2
         when: server is defined and path is defined and file is defined

       - name: xrdcp from xrootd federation server1 to here
         command: "xrdcp root://{{ xfed_server1 }}{{ xfed_pathfile }} /tmp/{{ file }}3"
         notify: cleanup3
         when: xfed_server1 is defined and xfed_pathfile is defined

       - name: xrdcp from xrootd federation server2 to here
         command: "xrdcp root://{{ xfed_server2 }}{{ xfed_pathfile }} /tmp/{{ file }}4"
         notify: cleanup3
         when: xfed_server2 is defined and xfed_pathfile is defined

       - name: xrdcp from xrootd federation server3 to here
         command: "xrdcp root://{{ xfed_server3 }}{{ xfed_pathfile }} /tmp/{{ file }}5"
         notify: cleanup3
         when: xfed_server3 is defined and xfed_pathfile is defined

       - name: debug print checksums of fetched files
         debug: var={{ item }}.stat.checksum verbosity=1
         when: server is defined and path is defined and file is defined
         with_items:
           - "reg_bash_1"
           - "reg_bash_2"

       - name: assert that checksums are all the same
         assert:
           that:
             - "bash_checksum == {{ item }}.stat.checksum"
         when: server is defined and path is defined and file is defined
         with_items:
           - "reg_bash_1"
           - "reg_bash_2"


        # One could use glue-validator instead for BDII testing
       - name: ldapsearch tool comes from openldap-clients on redhat
         command: "rpm -qa openldap-clients"
         register: reg_openldap
         failed_when: reg_openldap.stdout == ""
         when: ansible_os_family == "RedHat" and enable_ldap_testing

       - name: ldapsearch tool comes from ldap-utils on debian
         command: "dpkg --get-selections ldap-utils"
         register: reg_ldap_utils
         failed_when: reg_ldap_utils.stdout == ""
         when: ansible_os_family == "Debian" and enable_ldap_testing

       - name: shell ldapsearch towards server port 2170 and grep for GlueSESizeTotal
         shell: "ldapsearch -LL -x -H ldap://{{ server }}:2170 -b o=grid GlueSESizeTotal|grep -c ^GlueSESizeTotal"
         register: reg_ldapsearch
         failed_when: reg_ldapsearch.rc != 0 or reg_ldapsearch.stdout != "1"
         changed_when: reg_ldapsearch.stdout != "1"
         when: enable_ldap_testing

       - name: debug print ldapsearch
         debug: var=reg_ldapsearch verbosity=1
         when: enable_ldap_testing


       delegate_to: localhost
       # end of block

...

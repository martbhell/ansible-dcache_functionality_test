---

 - name: test a storage element
   hosts: localhost
   gather_facts: True
   force_handlers: True
   become: False

   vars:
     # these can be overridden with adding parameter "-e variable=value" to the ansible-playbook command
     ldap_server: "{{ server }}"
     xrootd_server: "{{ server }}"
     srm_server: "{{ server }}"
     https_server: "{{ server }}"
     ldap_port: 2170
     ldap_gluename: "GlueSESizeTotal"
     xrdcp_write_expected_return_code: 0 # set this to 54 to expect a write failure
     https_write_expected_return_code: 1 # set this to 0 to expect a write success

   handlers:
     - name: cleanup
       command: arcrm srm://{{ server }}{{path}}/{{ file }}
     - name: cleanup2
       file: path=/tmp/{{ file }} state=absent
     - name: cleanup3
       file: path=/tmp/{{ file }}{{ item }} state=absent
       with_items:
        - 2
        - 3
        - 4
        - 5
        - 6
     - name: cleanup_xrdcp_write
       command: arcrm srm://{{ server }}{{path}}/{{ file }}_write
       ignore_errors: True
     - name: cleanup_https_write
       command: arcrm srm://{{ server }}{{path}}/{{ file }}_https_write
       ignore_errors: True

   tasks:
     - block:

# Safety 

       - name: findproxy validity - fails if no (valid) proxy found 
         command: arcproxy -i validityLeft
         register: reg_arcproxy
         changed_when: False
         failed_when:
           - reg_arcproxy.rc != 0 or reg_arcproxy.stdout|int == 0

# Listing and cleanup

       - name: arcls SRM dir
         command: "arcls srm://{{ srm_server }}{{ path }}"
         register: reg_arcls
         when: server is defined and path is defined

       - name: arcls SRM path / file
         command: "arcls srm://{{ srm_server }}{{ path }}/{{ file }}"
         register: reg_arclsfile
         failed_when: False
         when: server is defined and path is defined and file is defined

       - name: arcls SRM path / file_xrdcp write
         command: "arcls srm://{{ srm_server }}{{ path }}/{{ file }}_write"
         register: reg_arclsfile_xrdcp_write
         failed_when: False
         when: server is defined and path is defined and file is defined

       - name: arcls SRM path / file_https write
         command: "arcls srm://{{ srm_server }}{{ path }}/{{ file }}_https_write"
         register: reg_arclsfile_https_write
         failed_when: False
         when: server is defined and path is defined and file is defined

       - name: arcrm SRM file_xrdcp write first if it exists
         command: "arcrm srm://{{ srm_server }}{{ path }}/{{ file }}_write"
         when: 
          - reg_arclsfile_xrdcp_write.rc|int == 0
          - (server is defined and path is defined and file is defined)

       - name: arcrm SRM file first if it exists
         command: "arcrm srm://{{ srm_server }}{{ path }}/{{ file }}"
         when: 
          - reg_arclsfile.rc|int == 0
          - (server is defined and path is defined and file is defined)

       - name: arcrm SRM https_file first if it exists
         command: "arcrm srm://{{ srm_server }}{{ path }}/{{ file }}_https_write"
         when: 
          - reg_arclsfile_https_write.rc|int == 0
          - (server is defined and path is defined and file is defined)

       - name: xrdfs ls
         command: "xrdfs root://{{ xrootd_server }}{{ path }}"
         register: reg_xrdfs
         when: server is defined and path is defined

# Checksum of original file

       - name: stat bash
         stat: path=/bin/bash
         register: reg_bash

       - name: store bash checksum in a fact
         set_fact: 
           bash_checksum: "{{ reg_bash.stat.checksum }}"

# Copy files here and there

       - name: arccp SRM here to there
         command: "arccp /bin/bash srm://{{ srm_server }}{{ path }}/{{ file }}"
         notify: cleanup
         when: server is defined and path is defined and file is defined

       - name: arccp SRM there to here
         command: "arccp srm://{{ srm_server }}{{ path }}/{{ file }} /tmp/{{ file }}"
         notify: cleanup2
         when: server is defined and path is defined and file is defined

       - name: xrdcp there to here
         command: "xrdcp root://{{ xrootd_server }}{{ path }}/{{ file }} /tmp/{{ file }}2"
         notify: cleanup3
         when: server is defined and path is defined and file is defined

# Try to write with xrdcp too

       - name: xrdcp here to there - fail if return code is not xrdcp_write_expected_return_code
         command: "xrdcp /bin/bash root://{{ xrootd_server }}{{ path }}/{{ file }}_write"
         when: server is defined and path is defined and file is defined
         register: reg_xrdcp_write
         failed_when: reg_xrdcp_write.rc != xrdcp_write_expected_return_code|int
         notify: cleanup_xrdcp_write

# Https/webdav

       - name: arccp https here to there
         command: "arccp /bin/bash https://{{ https_server }}:2880{{ path }}/{{ file }}_write_https"
         register: reg_https_write
         notify: cleanup_https_write
         failed_when: reg_https_write.rc != https_write_expected_return_code|int
         when: server is defined and path is defined and file is defined

       - name: arccp https there to here
         command: "arccp https://{{ https_server }}:2880{{ path }}/{{ file }} /tmp/{{ file }}6"
         notify: cleanup3
         when: server is defined and path is defined and file is defined

# Checksum after copying

       - name: stat fetched bash file
         stat: path=/tmp/{{ file }}
         register: reg_bash_1
         when: server is defined and path is defined and file is defined

       - name: stat fetched bash file2
         stat: path=/tmp/{{ file }}2
         register: reg_bash_2
         when: server is defined and path is defined and file is defined

       - name: debug print checksums of fetched files
         debug: var={{ item }}.stat.checksum verbosity=1
         when: server is defined and path is defined and file is defined
         with_items:
           - "reg_bash_1"
           - "reg_bash_2"

       - name: assert that checksums are all the same
         assert:
           that:
             - "bash_checksum == {{ item }}.stat.checksum"
         when: server is defined and path is defined and file is defined
         with_items:
           - "reg_bash_1"
           - "reg_bash_2"

# Federation

       - name: xrdcp from xrootd federation server1 to here
         command: "xrdcp root://{{ xfed_server1 }}{{ xfed_pathfile }} /tmp/{{ file }}3"
         notify: cleanup3
         when: xfed_server1 is defined and xfed_pathfile is defined

       - name: xrdcp from xrootd federation server2 to here
         command: "xrdcp root://{{ xfed_server2 }}{{ xfed_pathfile }} /tmp/{{ file }}4"
         notify: cleanup3
         when: xfed_server2 is defined and xfed_pathfile is defined

       - name: xrdcp from xrootd federation server3 to here
         command: "xrdcp root://{{ xfed_server3 }}{{ xfed_pathfile }} /tmp/{{ file }}5"
         notify: cleanup3
         when: xfed_server3 is defined and xfed_pathfile is defined

# Information system: One could use https://github.com/quinot/ansible-plugin-lookup_ldap instead - or perhaps glue-validator

       - name: ldapsearch tool comes from openldap-clients on redhat
         command: "rpm -qa openldap-clients"
         register: reg_openldap
         failed_when: reg_openldap.stdout == ""
         when: ansible_os_family == "RedHat" and enable_ldap_testing

       - name: ldapsearch tool comes from ldap-utils on debian
         command: "dpkg --get-selections ldap-utils"
         register: reg_ldap_utils
         failed_when: reg_ldap_utils.stdout == ""
         when: ansible_os_family == "Debian" and enable_ldap_testing

       - name: shell ldapsearch towards ldap_server port ldap_port and grep for ldap_gluename
         shell: "ldapsearch -LL -x -H ldap://{{ ldap_server }}:{{ ldap_port }} -b o=grid {{ ldap_gluename }}|grep -c ^{{ ldap_gluename }}"
         register: reg_ldapsearch
         failed_when: reg_ldapsearch.rc != 0 or reg_ldapsearch.stdout != "1"
         changed_when: reg_ldapsearch.stdout != "1"
         when: enable_ldap_testing

       - name: debug print ldapsearch
         debug: var=reg_ldapsearch verbosity=1
         when: enable_ldap_testing


       delegate_to: localhost
       # end of block

...
